PublicOS 2.0：物理AIシミュレーターから自律型空間オペレーティングシステムへの進化的再設計に関する包括的技術レポート
第1章 エグゼクティブサマリーと戦略的ビジョン
1.1 背景と課題：静的GISからの脱却
当初の「PublicOS」構想は、物理法則を内包したAIシミュレーターとしての基盤を提示し、Project PLATEAUや国土地理院（GSI）データを活用した自然言語によるシミュレーション環境の構築を目指していました。しかし、現代の空間コンピューティング（Spatial Computing）の潮流は、単なる「個人のためのシミュレーションツール」から、組織やチームがリアルタイムで協働し、外部の知見をプラグインとして動的に取り込み、かつ実世界の交通流や気象変化を滑らかに再現する「生きたオペレーティングシステム」へと急速にシフトしています。
本レポート「PublicOS 2.0」は、先行する革新的プラットフォームであるFelt.com（コラボレーションとデータパイプライン）、Re:Earth（拡張性とプラグインアーキテクチャ）、そしてMini Tokyo 3D（リアルタイムデータの補間と可視化）の技術的優位性を徹底的に分析し、それらを当初の設計に統合した改正版のアーキテクチャ設計書です。
1.2 PublicOS 2.0における4つの技術的柱
本改正案では、システムの核となる要素を以下の4つの柱として再定義し、それぞれの実装戦略を具体化します。
| 核となる要素 | PublicOS 1.0 (旧設計) | PublicOS 2.0 (改正設計) | 技術的参照元 |
|---|---|---|---|
| データ基盤 | 静的なGSI/PLATEAUデータの変換 | 「Upload Anything」パイプライン: サーバーレス環境でのTippecanoeによる動的タイリングとPMTiles形式の採用により、数GB級のデータを即座に可視化・共有可能にする。 | Felt.com |
| 協調性 | シングルユーザー環境 | マルチプレイヤーCRDTファブリック: YjsとWebSocketを用いた状態同期により、Google Docsのように複数人が同時に地図を操作・描画・解析する環境を実現する。 | Felt / Figma |
| 拡張性 | 固定的なコードベース | WebAssemblyサンドボックス: QuickJSをWASM内で動作させ、サードパーティが安全にロジックやUIを拡張できるプラグインシステムを構築する。 | Re:Earth |
| 時間表現 | 離散的な更新 | 予測的補間ループ: APIからの断続的な位置情報を、線形補間（LERP）や球面線形補間（SLERP）を用いて60fpsの滑らかなアニメーションに変換する。 | Mini Tokyo 3D |
1.3 本レポートの目的と構成
本ドキュメントは、単なる機能要件定義書ではなく、エンジニアリングチームが実装に着手するための詳細な技術仕様書として機能することを目的としています。各章では、理論的背景、技術選定の根拠、具体的な実装パターン、そしてそれらがもたらす「物理AI」としての進化について詳述します。特に、大規模言語モデル（LLM）であるClaudeが、これらの高度な機能をどのようにオーケストレーション（指揮）し、ユーザーの意図を具体的なシステム操作に変換するかという「エージェンティック（Agentic）な振る舞い」についても深掘りします。
第2章 コア・アーキテクチャ：ハイブリッド「インターリーブ」レンダリング戦略
空間アプリケーションのUX（ユーザー体験）とパフォーマンスを決定づける最大の要因は、レンダリングエンジンの選定と統合方法にあります。PublicOS 1.0ではMapboxとdeck.glの併用が提案されていましたが、2.0ではこれをさらに推し進め、FeltやRe:Earthの知見を取り入れた「インターリーブ（Interleaved）」レンダリングを標準とします。
2.1 2.5次元と真の3次元のジレンマの解消
地理空間情報の可視化には、大きく分けて2つのアプローチが存在します。
 * CesiumJS（真の3次元）: WGS84楕円体をベースとし、宇宙空間や地下構造を含む地球規模の正確な表現に優れます。Re:Earthはこのエンジンを採用しており、デジタルツインの精度において強力な基盤を持っています 。
 * Mapbox GL JS / MapLibre（2.5次元/Web Mercator）: 都市レベルでの詳細な地図表現、ベクタータイルのスタイリング、そしてUIの応答速度に優れます。FeltやMini Tokyo 3Dはこちらを採用またはベースとしており、一般的なWebアプリケーションとしての「使いやすさ」で勝ります 。
PublicOS 2.0では、都市シミュレーションとユーザー操作性を最優先するため、Mapbox GL JS v3をベースとしつつ、物理シミュレーション層としてdeck.glを統合する構成を採用します。
2.2 「インターリーブ」モードによる深度統合
従来のWebGISでは、ベースマップ（Mapbox）の上に別のCanvas（deck.gl）をオーバーレイとして重ねる手法が一般的でした。しかし、これでは「3Dの建物の陰にドローンが隠れる」といった前後関係（オクルージョン）が正しく描画されず、物理シミュレーターとしてのリアリティを損ないます。
本設計では、deck.glのMapboxOverlayクラスを使用し、interleaved: trueオプションを有効化します 。
 * 技術的メカニズム: この設定により、deck.glは独自のWebGLコンテキストを作成するのではなく、Mapboxが生成したWebGL2コンテキストを共有します。deck.glのレイヤーはMapboxのレイヤースタックの中に注入され、共通の深度バッファ（Depth Buffer）を使用することになります。
 * メリット: PLATEAUの3D都市モデル（Mapbox側で描画）と、風況シミュレーションのパーティクル（deck.gl側で描画）が互いに正しく遮蔽し合い、視覚的に矛盾のない統合環境が実現されます。これにより、ユーザーは直感的に空間的な位置関係を把握できるようになります。
2.3 フロントエンド・フレームワークと状態管理
アプリケーションの骨格には、堅牢性とパフォーマンスのバランスから**Next.js 14+ (App Router)**を採用します。しかし、地図アプリケーション特有の高頻度な状態更新（マウス移動、視点変更）に対応するため、状態管理には特別な配慮が必要です。
 * ローカルステート (UI): サイドバーの開閉やツール選択など、レンダリングに直結しない状態はZustandまたはJotaiで管理します。Feltの開発チームは、複雑な依存関係を持つ状態管理においてJotaiのアトム（Atom）モデルが再レンダリングを最小限に抑える上で有効であることを示唆しています 。
 * 共有ステート (CRDTs): 後述するコラボレーション機能の中核として、地図の状態そのものをYjsによって管理します。これにより、ローカルでの操作が即座にネットワーク経由で同期可能なデータ構造として保持されます。
第3章 「Upload Anything」データパイプライン：Felt.comのアーキテクチャ統合
従来のGISにおける最大の障壁は、データの「前処理」でした。Felt.comが実現した「Upload Anything（何でもアップロード）」の体験は、ユーザーがファイル形式や座標系を意識することなく、ドラッグ＆ドロップだけで地図を作成できる点にあります。PublicOS 2.0では、この体験を再現するためのサーバーレス・パイプラインを構築します。
3.1 Tippecanoeによるサーバーレス・タイリング
巨大なGeoJSONやShapefileをブラウザで直接レンダリングしようとすると、メモリ不足やフレームレートの低下を招きます。これを解決するために、Mapboxが生み出し現在はFeltがメンテナンスしているツールTippecanoeを活用します 。
3.1.1 パイプラインの設計
 * データ受領: ユーザーがファイルをアップロードすると、S3互換のオブジェクトストレージに一時保存されます。
 * 変換と正規化: AWS LambdaやGoogle Cloud Runなどのサーバーレス関数がトリガーされ、GDAL/OGRを用いてあらゆる形式（KML, GPX, Shapefile）をGeoJSONシーケンスに変換します。
 * 動的ベクトルタイル生成: Tippecanoeを実行し、ズームレベルに応じた詳細度の調整（Simplification）と、高密度なデータの「間引き（Dropping）」を行います。
   * コマンド例: tippecanoe -zg --drop-densest-as-needed -o data.pmtiles input.geojson
   * このプロセスにより、数GBのデータであっても、ブラウザが処理可能なサイズのベクトルタイルセットに変換されます 。
3.2 PMTilesとエッジ配信の革新
生成されたタイルデータの配信には、PMTiles形式を採用します。これは単一のファイルアーカイブでありながら、HTTPのRange Request（範囲リクエスト）に対応しています 。
 * インフラコストの削減: 従来のXYZタイルサーバー（多数の小さなファイルを配信するサーバー）を常時稼働させる必要がありません。S3などのストレージに.pmtilesファイルを置くだけで、ブラウザが必要なタイル部分だけをバイト単位で取得します。
 * PublicOSへの適用: これにより、ユーザーがアップロードした「風況観測データ」や「ドローン飛行ログ」といった動的なデータセットを、追加のサーバーコストなしに即座に共有・可視化することが可能になります。
3.3 AIによる「セマンティック・スタイリング」
FeltのUXにおけるもう一つの革新は、データの属性を理解して適切なスタイルを自動適用する点です 。PublicOS 2.0では、LLMを活用してこのプロセスを強化します。
 * データアップロード時に属性テーブルをスキャンします。
 * 属性名に「elevation」「height」「階数」などが含まれる場合 → 3D押し出し（Extrusion）スタイルを自動適用。
 * 属性名に「speed」「velocity」が含まれる場合 → 色のグラデーション（Color Ramp）を適用。
 * 点群データが密集している場合 → ヒートマップまたはクラスタリング表示を提案。
   これにより、「データを表示する」だけでなく「データの意味を理解する」インターフェースを実現します。
第4章 コラボレーション基盤：CRDTとリアルタイム同期
PublicOS 1.0は「個人のためのツール」でしたが、都市計画や災害対応は本質的に「チームで行う活動」です。FeltやFigmaが証明したように、リアルタイムでの共同編集機能はプラットフォームの価値を指数関数的に高めます。
4.1 CRDT（紛争なき複製データ型）の導入
Google Docsなどが採用しているOT（Operational Transformation）方式は、中央サーバーでの順序制御が必要であり、複雑化しやすい欠点があります。対して、分散システムに適した**CRDT（Conflict-free Replicated Data Type）**は、各クライアントが独立して状態を持ち、それらを数学的に矛盾なくマージすることができます 。
PublicOS 2.0では、JavaScript向けの高性能CRDTライブラリであるYjsを採用します 。
 * データモデル: 地図の状態を単一のJSONオブジェクトではなく、Yjsの共有型（Shared Types）として定義します。
   * yMap('viewState'): カメラの位置（緯度・経度・ズーム・ピッチ）。
   * yArray('layers'): 表示されているレイヤーのリストと順序。
   * yMap('simulationParams'): 風速、ドローンの積載量などの物理パラメータ。
   * yArray('annotations'): ユーザーが描画した注釈や図形。
4.2 WebSocketとアウェアネス（存在感）の実装
コラボレーションの「臨場感」を生み出すために、WebSocketサーバー（Hocuspocusなど）を介して各クライアントのカーソル位置や選択状態を同期します 。
4.2.1 カーソル・プレゼンスの実装
Feltにおいて他者のマウスカーソルが見える機能は、ユーザーの孤独感を解消し、「同じ場所にいる」感覚を醸成します 。
 * 実装戦略: マウスの移動イベントをスロットリング（間引き）し、約30〜50msごとにWebSocketへ送信します。
 * deck.glによる描画: 受信した他ユーザーの座標データは、Reactの状態として管理するのではなく、deck.glのIconLayerとして描画します。これにより、Reactの再レンダリングサイクル（DOM更新）のオーバーヘッドを回避し、60fpsのスムーズなカーソル移動を実現します。
 * 補間処理: ネットワーク遅延によるカーソルの飛び跳ねを防ぐため、受信した座標間を線形補間（LERP）することで、滑らかな動きを表現します 。
4.3 物理パラメータの同期と競合解決
例えば、ユーザーAが「風速」を10m/sに変更し、同時にユーザーBが「風速」を15m/sに変更した場合、YjsのLast-Write-Wins（LWW）アルゴリズムにより、タイムスタンプが新しい方の変更が即座に全員に反映されます。これにより、シミュレーション条件の不整合を防ぎつつ、会議中などに「パラメータをいじりながら議論する」という動的なワークフローが可能になります。
第5章 拡張性カーネル：Re:Earth型プラグインシステムとWASMサンドボックス
PublicOSが「OS」を名乗るためには、ユーザー自身が機能を追加できる拡張性が不可欠です。しかし、Webブラウザ上で任意のJavaScriptコードを実行させることはセキュリティ上の重大なリスク（XSS攻撃など）を伴います。Re:Earthはこの問題を解決するために、**WebAssembly (WASM)**を活用したサンドボックスアーキテクチャを採用しています 。
5.1 QuickJS + WASMによる安全な実行環境
PublicOS 2.0では、軽量なJavaScriptエンジンであるQuickJSをWASMにコンパイルし、ブラウザ内で「仮想マシン」として稼働させます 。
5.1.1 プラグインの分離モデル
プラグインは以下の2つのコンテキストに厳密に分離されます。
 * ロジック・コンテキスト (WASM内):
   * ここで計算ロジック（例：独自の洪水浸水想定アルゴリズム）が実行されます。
   * この環境からは、ブラウザのDOM、Cookie、LocalStorage、ネットワーク（特定のエンドポイント以外）へのアクセスが完全に遮断されています。
   * PublicOS本体から提供されたAPI（reearthオブジェクト相当）を通じてのみ、地図データの読み書きが可能です。
 * UIコンテキスト (iframe内):
   * 設定パネルや独自のグラフ表示を行うためのHTML/CSS/JSです。
   * サンドボックス化された<iframe>内で動作し、親ウィンドウ（PublicOS本体）とはpostMessageのみで通信します 。
5.2 プラグインによる「物理AI」の民主化
このアーキテクチャにより、以下のような高度な拡張が可能になります。
 * 独自物理モデルの追加: ユーザーはドローンのバッテリー消費モデルをTypeScriptで記述し、プラグインとしてアップロードするだけで、システム本体を改修することなくシミュレーションロジックを差し替えることができます。
 * 外部API連携: 特定の気象データプロバイダからリアルタイムデータを取得し、それをマップ上に可視化するプラグインを安全に配布できます。
 * 秘匿計算: WASM内で処理が完結するため、機密性の高い計算ロジック（例：防衛関連の経路探索）をクライアントサイドのみで実行し、サーバーにロジックを送信することなく利用可能です。これは「ソブリンAI」の観点からも重要です 。
第6章 シミュレーションと時間表現：Mini Tokyo 3Dのアニメーションループ
「物理AIシミュレーター」としての正確性は、時間の経過とともに変化するデータをいかに滑らかに表現するかにかかっています。APIから数秒おきに送られてくる離散的な位置情報をそのまま表示すると、オブジェクトは「テレポート」するようにカクカクと動いてしまいます。Mini Tokyo 3Dは、この問題を高度な補間アルゴリズムで解決しています 。
6.1 アニメーションループと状態バッファリング
リアルタイム性を保ちつつ滑らかな描画を行うために、以下の処理フローを実装します。
 * データ受信とバッファリング: ドローンや風況のデータパケット（t_0, t_1, t_2...）を受信した際、即座に描画するのではなく、一度バッファ（キュー）に蓄積します。
 * レンダリング時間の遅延: 描画上の現在時刻（Render Time）を、実際の現在時刻よりわずかに（例えば500ms〜2秒）遅らせて設定します。これにより、常に「過去の確定した2点（t_{prev}$と$t_{next}）」の間を補間することになり、未来のデータが未着のために動きが止まることを防ぎます。
6.2 高度な補間技術：LERPとSLERP
Mapboxやdeck.glの標準的なトランジション機能を超え、物理的な挙動を正しく再現するために、独自の補間ロジックを実装します 。
 * 線形補間 (LERP): 位置座標（緯度・経度・高度）の計算に使用します。
   
   
   ここで、tは現在のアニメーション時刻、$t_{start}, t_{end}$はデータポイントのタイムスタンプです。
 * 球面線形補間 (SLERP): ドローンの機首方位（Heading）や姿勢（Quaternion）の計算に使用します。単純な線形補間では回転が最短距離を通らない場合や、歪みが生じる場合がありますが、SLERPを用いることで、旋回動作が物理的に自然な円弧を描くようになります。
6.3 多数オブジェクトの描画最適化（Instancing）
Mini Tokyo 3Dが2,200以上の列車を同時にスムーズに動かせるのは、GPUの**インスタンシング（Instancing）**技術を活用しているためです 。PublicOS 2.0でもdeck.glのScenegraphLayerを使用し、ドローンの3Dモデルジオメトリを一度だけGPUに転送し、各フレームでは位置と回転の行列情報（Matrix）のみを更新する方式をとります。これにより、数千台のドローンが飛び交う物流シミュレーションでも、ブラウザの負荷を最小限に抑えることが可能です。
第7章 AIカーネル：エージェンティック・ワークフローの統合
PublicOS 2.0におけるClaude（LLM）の役割は、単なるチャットボットを超えた「システムオペレーター」です。ユーザーの自然言語による指示を理解し、上述した各機能モジュールを**Function Calling（ツール使用）**によって直接操作します。
7.1 定義される「ツール」群
AIがシステムを操作できるように、APIをJSONスキーマとして定義し、AIに公開します。
 * upload_data(url): 指定されたURLからデータを取得し、Tippecanoeパイプラインに投入する。
 * set_simulation_params(params): Yjsの共有ステートを更新し、風速や積載量などの変数を変更する。
 * add_plugin(plugin_id): Re:Earthのエコシステムから特定の解析プラグインをインストールし、WASMサンドボックスで起動する。
 * run_interpolation(mode): アニメーションの補間モード（リアルタイム重視か、スムーズさ重視か）を切り替える。
7.2 インタラクションの具体例
ユーザー: 「台風接近時の港区におけるドローン配送のリスクをシミュレーションして。風速は25m/sで。」
Claudeの推論と実行プロセス:
 * 文脈理解: 「台風」→ 強風、雨のパラメータが必要。「港区」→ 地図の移動。「ドローン配送」→ 物流シミュレーションプラグインの活性化。
 * ツール実行 1: map.flyTo({ location: "Minato-ku", zoom: 14 }) を呼び出し、視点を移動。
 * ツール実行 2: simulation.setEnv({ windSpeed: 25, condition: "typhoon" }) を呼び出し、共有ステートを更新（全ユーザーの画面で風が強まる）。
 * ツール実行 3: plugins.activate("drone-risk-analyzer") を呼び出し、WASM内でリスク計算を開始。
 * 結果報告: プラグインから返された計算結果（「バッテリー消費量が通常時の1.5倍、ビル風による墜落リスク高」）を受け取り、自然言語でユーザーに回答する。
このように、AIはUIの一部として振る舞い、複雑な設定画面を操作することなく高度なシミュレーションを実行可能にします。
第8章 実装ロードマップとフェーズ定義
PublicOS 2.0の構築には、段階的なアプローチが必要です。各フェーズは、前述の4つの柱（データ、協調、拡張、時間）を順次確立するように設計されています。
フェーズ1：ソブリン・ファウンデーション（基盤構築）
 * 目標: Next.js上でMapbox v3とdeck.glのインターリーブレンダリングを確立する。
 * 主要タスク:
   * Next.jsプロジェクトのセットアップとMapbox GL JS v3の導入。
   * MapboxOverlayを用いたdeck.glの統合（interleaved: true）。
   * GSI標高タイル（Terrain-RGB）の読み込みと3D地形表示の実装。
 * 成果物: 3D地形と都市モデルが表示され、スムーズに操作できるベースマップ。
フェーズ2：コラボレーション・ファブリック（同期基盤）
 * 目標: 複数ユーザー間での地図状態とカーソルの同期を実現する。
 * 主要タスク:
   * WebSocketサーバー（Hocuspocus等）の立ち上げ。
   * クライアント側でのYjsの導入と、Mapboxのカメラ状態とのバインディング。
   * 他ユーザーのカーソルを表示するdeck.glレイヤーの実装。
 * 成果物: URLを共有するだけで、同じ地図を同時に見て操作できる「マルチプレイヤー地図」。
フェーズ3：データ・パイプライン（取り込み基盤）
 * 目標: ユーザーが任意のデータをドラッグ＆ドロップで可視化できるようにする。
 * 主要タスク:
   * Tippecanoeを含むコンテナイメージの作成とサーバーレス環境（Lambda等）へのデプロイ。
   * S3バケットの設定と、PMTiles形式でのデータ保存・配信構成。
   * フロントエンドでのファイルアップロードUIと、自動スタイル適用ロジックの実装。
 * 成果物: GeoJSONファイルをドロップすると、数秒後に地図上に可視化される機能。
フェーズ4：プラグイン・カーネル（拡張基盤）
 * 目標: 第三者がロジックを追加できる安全なサンドボックス環境を構築する。
 * 主要タスク:
   * quickjs-emscriptenの導入とWASMワーカーの構築。
   * メインスレッドとWASM間の通信ブリッジ（API）の設計と実装。
   * サンプルの物理計算プラグイン（例：簡易的な距離・エネルギー計算）の作成。
 * 成果物: ユーザー作成のスクリプトを読み込み、安全に実行できるプラグインシステム。
フェーズ5：シミュレーション・ループ（時間表現）
 * 目標: リアルタイムデータやシミュレーション結果を滑らかにアニメーションさせる。
 * 主要タスク:
   * 物理演算の結果を時系列データとしてバッファリングするロジックの実装。
   * requestAnimationFrame内でのLERP/SLERP補間処理の実装。
   * Mini Tokyo 3Dを参考にした、フレームレート非依存のレンダリングループの確立。
 * 成果物: カクつきのない、流れるようなドローンや風の動きの表現。
フェーズ6：AIオーケストレーション（統合）
 * 目標: 自然言語ですべての機能を操作可能にする。
 * 主要タスク:
   * Claude API（またはOpenAI API）との接続と、Function Callingのスキーマ定義。
   * AIのアクションに対するフィードバックループ（実行結果の解釈と再提示）の構築。
 * 成果物: 「○○をシミュレーションして」と頼むだけで、データ読み込みから設定、実行までをこなすAIアシスタント。
第9章 結論：次世代の社会インフラとしてのPublicOS
PublicOS 2.0は、既存のGISの枠組みを超えた、真の意味での「空間オペレーティングシステム」です。
 * Feltの哲学を取り入れることで、GISの専門家でなくとも扱えるデータアクセシビリティを確保しました。
 * Re:Earthのアーキテクチャを採用することで、将来の未知の要求にも対応できる拡張性と安全性を担保しました。
 * Mini Tokyo 3Dの技術を応用することで、物理現象を違和感なく人間に伝える表現力と正確性を獲得しました。
 * そして、これらをCRDTとAIで統合することで、組織の垣根を超えた協調的な意思決定を可能にします。
このシステムは、物流の最適化、災害時の迅速な状況把握、都市開発の合意形成など、物理世界における複雑な課題を解決するための強力なデジタル基盤となるでしょう。静的な地図を眺める時代は終わり、我々は地図の中でシミュレーションし、対話し、未来を設計する時代へと移行します。PublicOS 2.0はそのための羅針盤となるものです。
